slide  #0         => Welcome page, waiting to start
                     Hello, we're here today for a tutorial session to see in action how to build an embedded DSL
                     To make it fun : the guiding Theme of this presentation aims at focusing on a DSL to pilot characters on a grid and let them interact to
                     each others. 
                     Title of the game refers to Logo which off course, was part of our inspiration.
                     In our live session, we intend to show how we achieved this, the problems we met and how we solved them. 
                     DSLs exist on various popular languages like Ruby, Clojure and of course the ones of interest here Groovy and Scala.
                     In order to evaluate the differences that the underlying languages offer we picked two different languages that can be 
                     seen as theoretically strongly opposed using very different paradigms.
1:30
slide  #1         => Corinne starts the Agenda, up to part II
                     Pascal finishes with part III and Conclusion

Transition 1->2   => Pascal asks Corinne: but before maybe we can introduce ourselves. Ladies first please
slide  #2         => skip
slide  #3         => Corinne introduces herself
                     over 15 years of experience in IT,
                     co-founder of French Riviera GUG,
                     part of 3must33rs writing mobile plugins for Grails
                     active member of JS Sophia
                     joined Red Hat
                     work for AeroGear mobile platform.
                     female geek and supporter Duchess France
                     use to be freelance consultant for Amadeus in Sophia Antipolis where I met my geek friend

slide  #4         => Pascal introduces himself
                     Architect in e-commerce solutions at Amadeus with 12 years of experience in IT
                     Like mountaineering and video games and when I have some free time left, 
                     curious about programming languages,and storage solutions
                     Recently converted to BSD (PC-BSD rocks)
                     Regular participant to Scala and Clojure User Group
                     Proposal: joke: not a big fan of cat therefore there won't be any cat in this prez.
Transition 4->5   => Pascal: You are here mainly to hear about DSLs. So first let's give you some Context
slide  #5         => Pascal starts explaining inside Amadeus the Scripting engine role
                     SSE in order to enable faster customers customization thanks to script
                     Sandboxing, defining of APIs and we started to design DSL to simplify user Customization.
                     Corinne continues
                     When Pascal was working in SSE, I was part of the business team writing Selling platform connect for TA
                     we had a use case of writing a DSL for TA to improve efficiency:
                     do a booking in a minute
                     At the same time I was building a team to participate at Grails48 hackathon with RivieraGUG
                     we wanted to have fun: DSL for kids and older kids
                     We initiated the idea of Kissing Turtles, a 2 players web based mobile app where Franklin
                     wants to meet Emily for a kiss. To navigate through the maze, kids (and older-kids) will write Groovy or Scala script. 
                     Kissing Turtles is a mobile game using 3musket33rs Grails plugins
                     Obviously, we were lucky to have testers on board. Kids can participate in hackathon :)
                     that was the genesis of KT.
Transition 5->6   => Pascal interrupts Corinne to ask her if she would mind giving us an overview of how we can define DSLs
slide  #6         => skip
slides #7 - 11    => Corinne
                     DSL Definition
                     DSL stands for Domain Specific language, but lets try to get clear grasp on it.
                     From Martin Fowler:
                     extract 3 key elements:

                     computer language: something executable by a computer

                     language: it should feel like a language where the syntax and the semantic put together offer a sense of fluency.
                     If you can read the SQL statement and understand the joke you get the idea of sense of fluency

                     last but not least, focused on a particular domain.
                     It is not a turing complete language as opposed to GPL.
                     If we take the ex of rubik cube, all we need is 6 letters for the 6 possible moves
                     and the apostrophe is giving you the rotation.

                     Last time I gave Riviera user groups meetup, one guy telling me
                     don't like M. fowler definition because it focus too much limited aspect of a DSL
                     prefer to focus on the expressive part of DSL
                     some DSL can be turing complete and shine by their expressiveness
                     Corinne says: I can see many advantages to DSL, but Pascal can you tell us when to use a DSL and
                     what are the pro and cons.
slides #12 - 13   => Pascal explains that boundaries are blurry. There is no clear distinction between a DSL and a good API.
                     What is important in a DSL is its expressiveness to describe in a simple and human readable way a process flow.
                     One of the key advantage of using a DSL is to share a common metaphor (notion borrowed from Agile development).
                     The ultimate goal being: code that reads as natural language, code that a domain expert, without programming
                     experience can read, understand and even write. Code that a 6 years old kid can handle!

                     Hal Abelson citation: Programs should be written for people to read, and only incidentally for machines to execute.
                     That makes a perfect fit for DSLs.

                     On the other hand, be aware of the disadvantages:
                     - lg cacophony
                     - On the other side of the spectrum is the Ghetto lg syndrom: in-house lg not used anywhere else.
                     Difficult to get new staff onboard. Usually happen when lg are not limited (wont fit Folwer definition)
                     - lack of support for IDE (some suport on Eclipe/intellij) but not so much for web based editor
                     - cost of building
                     Pascal says: Our presentation is about embedded DSL, what does that mean?
slides #14        => Corinne
                     DSl comes in different varieties.
                     Very often we distinguish 2 kinds of DSL, we also talked about the third type
                     - An external DSL is a language separated from the main language of the application it works with.
                     - It usually has its own custom syntax
                     - it is usually parsed by the host application:
                     use parser generators like ANTLR to parse your grammar and generate code in the underlying language.

                     - An internal DSL, also called an embedded DSL, is a subset of a GPL.
                     - It is valid code that can be directly executed in its host language.
                     It is in this category that our Groovy and Scala embedded DSLs fall in.
                     Can be more constrained by the embedding language syntax.

                     Those 2 kinds of DSl are traditional ways of thinking about DSL.
                     The lg workbench go beyond the textual representation of a DSL
                     Language users manipulate a DSL through a projectional editor.
                     lg workbench allows you to define a parser and a IDE at the same time
                     support for diagrammatic lgs.
slides #15        => Corinne
                     To go deeper on embedded DSL, Debasish Ghosh, we can differentiate between
                     purely embedded DSL where you write explicitly the DSL.
                     and the generative category where code is generated either runtime or compile time
                     In this embedded category, there is different techniques you use
                     - fluent API with command chaining
                     - AST transform like we'll see with Groovy
                     - or Type embedding we'll explore in Scala
                     - on dynamic side, reflective metaprogramming with the MOP usage in Groovy
                     so we talked about Ext vs Int, what's th epro and con of those 2 types?
slide  #16        => Pascal explains that it is generally simpler to use an Internal DSL because it can take advantage
                     of an enclosing existing language. Designing an External DSL is not so easy and it requires some grammar
                     specifications. In this Tuto, we are going to mainly focus on Internal DSLs.
Transition 16->17 => Pascal says: Now that we have chosen to use Embedded DSLs, which language should we choose.
                     This is our pure one minute trolling Pascal
                     Fire up
                     //I recommend Scala for the following reasons:
slide  #17        => Pascal and Corinne exchange on topics pro and against Scala and Groovy
Transition 17->18 => Time out! Ok now let's stop any troll debate and lets try to build our DSL in both languages to see
                     convergence and divergence.
slide  #18        => Corinne details Groovy features.
                     Groovy is particularly suited for DSL writting thks to:
                     syntax sugar: less ponctuation ; () optional
                     return statement optional
                     no getter setter for properties access
                     named parameters: pass a map to a constructor, omitting the map bracket
                     command chaining to write sentence
                     closure and closure delegate scope
                     runtime transformation MOP
                     compile time compilation AST
slides #19        => Pascal details Scala features.
Transition 19->20 => Pascal says that now we can start to dive into the DSL details
slides #20 - 21   => Corinne introduces the game, the target the rules
                     this is how the gameboard looks like: ramdom pisition for F and E. Meeting pt is ramdom too.
                     Each player takes turn and have a max of 3 moves.
slides #22 - 23   => Pascal explains that first as players will submit DSL, we need to evaluate the DSL inside the running
                     application. There exist different options. 
                     Introduce Groovy, Scala, JSR
                     And lets see how we can do in Groovy
slide  #24 - 27   => Code /Separate dedicated file
slide  #28        => Pascal explains the challenges of Scripting
slide  #29        => Corinne explains that if we want to enrich script interaction, we need bindings
                     But Pascal, in our script we define the move method and left variable each time,
                     I obviously want to extract those from my script
                     we need binding & compiler configuration
slide  #30        => In groovy, one way to extract the move method from the script is to use BaseClass
                     To define a new Baseclass we use Compiler configuration
                     also can be used to imports/static import for our script
                     and we'll see later how to use compil conf to define AST customizer
slides #31 - 36   => Code /Separate dedicated file
slide  #37        => Pascal explains that now we will enrich the DSL by creating Turtle and move
                     It's always a good ide to decouple Semantic model vs Syntax of the DSL
                     to evolve the model and the lg separately
slides #38 - 42   => Code /Separate dedicated file
slide  #43        => Pascal explains then that the DSL in itself does not handle UI. Everything inside the UI on client side
                     communicating thanks to JSON.
slides #44 - 47   => Code /Separate dedicated file
slides #48 - 49   => Corinne introduces Syntax/Command chaining
                     now that we have the semantic for the move, lets focus on
                     how we can enhance the syntax to sound like plain english
slides #50 - 51   => Code /Separate dedicated file
slide  #52        => Pascal asks about odd numbers
slides #53 - 54   => Code /Separate dedicated file
slide  #55        => Pascal discusses Scala Syntax in order to chain command
slides #56 - 57   => And evaluates DSL options. At the end the last proposal is chosen.
slides #58 - 59   => Code /Separate dedicated file
slide  #60        => Corinne introduces the kiss
slides #61 - 62   => Code /Separate dedicated file
slide  #63        => Corinne explains MOP
slide  #64        => Pascal says: Lets kiss in Scala
slides #65 - 66   => Code /Separate dedicated file
slide  #67        => Corinne explains that we might enrich classes behavior with Category or implicits
slides #68 - 71   => Code /Separate dedicated file
slide  #72        => Pascal reminds that it is important to secure the script because script writer could be malicious or distracted
slide  #73        => Corinne says Groovy has typeChecked for distracted users
slides #74 - 76   => Code /Separate dedicated file
slide  #77        => Pascal explains we don't need that in Scala because it is naturally strongly typed. What is fun is that
                     while Groovy is adding type checking, Scala has added Dynamics. It already had strcutural typing to safely
                     mimic duck typing of dynamic languages.
slides #78 - 79   => Code /Separate dedicated file
slide  #80        => Pascal asks and for malicious users ?
slides #81 - 84   => Code /Separate dedicated file
slide  #85        => Corinne says that we nedd also to prevent users from creating infinite loops
slides #86 - 89   => Code /Separate dedicated file
slide  #90        => Pascal explains that traits mixin can be an alternative to decorate behavior and creating interceptors
slide  #91        => But let's see that with the game rule that restrict the number of actions to 3
slides #92 - 95   => Code /Separate dedicated file
slide  #96        => Corinne suggests that now we have seen how to secure the script evaluation, we could try to add some interaction.
slide  #97        => and explains how to deal with in Groovy
slides #98 - 99   => Code /Separate dedicated file
slide  #100       => Pascal talks about Continuation as a complicated beast. 
                     Example are generally not very explicit.
                     Pascal suggests he wanted to take this opportunity to play with continuations.
slides #101 - 102 => Code /Separate dedicated file
slide  #103       => Corinne concludes: now that we have seen these different pieces of code. Let's put everything together 
                     and let's play.   
slide  #104       => Pascal explains that now, we just will enlarge the scope and talk about additional features.
slides #105 - 109 => Corinne <TODO>
slide  #110       => Pascal describes the Scala features that were not used in the game use cases
slide  #111       => Pascal now explains that we have alternative with External DSL. There is various tooling.
                     There are graphical tools (language is not the only way to reach expressiveness): they transformed UI behind the scenes 
                     into a programming language implementation. 
                     This graphical DSL has "simply" to fit into M. Fowler definition (DSL as a business focused language workbench)
                     External DSLs offer more expressiveness at the cost of more complexity.

slide  #112       => Corinne describes workbench
slide  #113       => Corinne then talks about Internationalization
Transition 113 - 114 => Pascal interrupts Corinne: Fine Corinne, anyway let's focus back on Internal DSL. And as a Developper, I have
                        concerns. First I am a strong believer in TDD. How can I test my DSL.
slide  #114       => Corinne covers main testing layers
slide  #115       => and describes the Groovy testing.
slide  #116       => Pascal then describes BDD testing with ScalaTest.
scala  #117       => Pascal switches now to debugging. Talking about local debugging but also remote ones and the difficulties.
slide  #118       => Pascal says: I think we covered all we wanted to show. It's time to conclude this duel.
slide  #119       => Corinne starts saying no one language solves all the problem.
                     Pascal continues that despite some issues, we were able to mix Scala and Groovy. So we should not fear polyglotism
                     and consider other languages.
slide  #120       => Together: and have fun!
                     It has been a fair battle between Groovy and Scala. There is one single winner: the JVM. 